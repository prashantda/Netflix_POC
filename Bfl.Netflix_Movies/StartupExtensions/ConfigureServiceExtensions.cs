using Bfl.Netflix.Core.Configurations;
using Bfl.Netflix.Core.Domain.Entities;
using Bfl.Netflix.Core.Domain.RepositoryContracts;
using Bfl.Netflix.Core.ServiceContracts;
using Bfl.Netflix.Core.Services;
using Bfl.Netflix.Infrastructure.Database;
using Bfl.Netflix.Infrastructure.Repositories;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Identity;
using Microsoft.EntityFrameworkCore;
using Microsoft.IdentityModel.Tokens;
using System.Text;
using System.Text.Json.Serialization;
using Microsoft.OpenApi.Models;
using Bfl.Netflix.Infrastructure.Repositories.Relationships;
using Bfl.Netflix_Service1.Core.ServiceContracts;
using Bfl.Netflix_Service1.Core.Services;
using Bfl.Netflix_Movies.Infrastructure.Repositories.Relationships;
using Bfl.Netflix_Movies.Core.ServiceContracts;
using Bfl.Netflix_Movies.Core.Services;
using MassTransit;
using Configurations;
using Bfl.Netflix_Movies.Core.AsyncDataServices;
using Confluent.Kafka;

namespace Bfl.Netflix.StartupExtensions
{
    public static class ConfigureServiceExtensions
    {
        public static IServiceCollection ConfigureServices(this IServiceCollection services,IConfiguration configuration)
        {
            services.AddCors(options =>
            {
                options.AddPolicy("AllowAll", b => b.AllowAnyHeader().AllowAnyOrigin().AllowAnyMethod());
                /*options.AddPolicy("AllowSpecificOrigins",
                                       builder =>
                                       {
                                           builder.WithOrigins("http://localhost:3000")
                                               .AllowAnyHeader()
                                               .AllowAnyMethod();
                                       });*/
            });


            services.AddControllers().AddJsonOptions(options =>           
                options.JsonSerializerOptions.Converters.Add(new JsonStringEnumConverter())//JsonStringEnumConverter is from  System.Text.Json.Serialization package
            );//To convert string from json to respective Enum this AddJsonOptions() is used 
            
            #region Database Configuration
            var host = Environment.GetEnvironmentVariable("HOST") ?? "PRASHANT\\SQLEXPRESS";
            var db = Environment.GetEnvironmentVariable("DATABASE") ?? "Netflix";
            var userId = Environment.GetEnvironmentVariable("USERID") ?? "root";
            var password = Environment.GetEnvironmentVariable("PASSWORD") ?? "zxcvbnm";
            var connection = $"Data Source={host}; Initial Catalog={db};User ID={userId};Password={password};Connect Timeout=30; Encrypt=False;";
            _ = services.AddDbContext<ApplicationDbContext>(options =>
            {
                //options.UseSqlServer(configuration.GetConnectionString("DefaultConnection"));
                options.UseSqlServer(connection);
                Configuration.ConnectionString = connection;

            });
            #endregion


            #region Security

            services.AddIdentityCore<ApplicationUser>(options =>
                    {
                        options.SignIn.RequireConfirmedEmail = false;
                        options.Password.RequireNonAlphanumeric = false;
                            options.Password.RequiredLength = 7;
                            options.Password.RequireDigit = false;
                            options.Password.RequireLowercase = true;
                            options.Password.RequireUppercase = false;
                            options.Password.RequiredUniqueChars = 2;
                
                     })
                    .AddRoles<ApplicationRole>()
                    .AddTokenProvider<DataProtectorTokenProvider<ApplicationUser>>("BFL_Netflix")
                                        /*registers a new token provider for the HotelListingApi resource in an ASP.NET Core application.
                                         A token provider is responsible for generating and validating security tokens, which are used
                                        to authenticate and authorize users or services in a system

                                        DataProtectorTokenProvider is being used, which is a built-in implementation 
                                        of the ITokenProvider interface in ASP.NET Core.
            
                                         The DataProtectorTokenProvider uses a data protection provider to encrypt and decrypt 
                                        tokens, which helps to prevent tampering or unauthorized access. The ApplicationUser type is 
                                        specified as the user data type for the provider, which means that tokens generated by 
                                        this provider will be associated with instances of the ApplicationUser class.*/
                    .AddEntityFrameworkStores<ApplicationDbContext>()//For storing and accessing data use this class
                    .AddDefaultTokenProviders();/*Token providers are used to generate and verify tokens 
                                         * that are used for tasks such as password reset, email
                                         * confirmation, two-factor authentication, and so on.
                                         * ASP.NET Core Identity provides a default set of token 
                                         * providers that are used by default, but you can customize
                                         * or replace them as needed*/

            services.AddAuthorization(options =>
            {
                                            /*AddAuthorization method configures the authorization system for the application. 
                                              The options parameter of this method is an instance of AuthorizationOptions, 
                                              which can be used to specify various authorization policies and requirements.*/
                         options.FallbackPolicy = new AuthorizationPolicyBuilder().RequireAuthenticatedUser().Build();
                /*sets a fallback authorization policy that will be used when no other policies apply. 
                  This policy is created using an instance of AuthorizationPolicyBuilder,
                  which provides a fluent interface for building authorization policies.

                    The policy is constructed with a single requirement, RequireAuthenticatedUser(),
                    which enforces that the user must be authenticated in order to access
                    any resource or action that requires authorization.*/
                

            });
            services.AddAuthentication(options =>
            {
                options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
                options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
            })
                    .AddJwtBearer(options=>
                    {
                        options.TokenValidationParameters = new TokenValidationParameters()
                        {
                            ValidateIssuerSigningKey = true,
                            ValidateIssuer = true,
                            ValidateAudience = true,
                            ValidateLifetime = true,
                            ClockSkew = TimeSpan.Zero,
                            IssuerSigningKey=new SymmetricSecurityKey(Encoding.UTF8.GetBytes(configuration["JwtSettings:Key"])),
                            ValidIssuer = configuration["JwtSettings:Issuer"],
                            ValidAudience = configuration["JwtSettings:Audience"]
                        };
                    });
            #endregion


            #region Azure Connection
            Configuration.AzureConnection = Environment.GetEnvironmentVariable("PUBLICCONNECTION")?? configuration.GetSection("BlobSettings:AzureConnectionString").Value;
            Configuration.AzureStorageName = Environment.GetEnvironmentVariable("AZURESTORAGE") ?? configuration.GetSection("BlobSettings:AzureStorageAccount").Value; 
            Configuration.AzureStorageKey = Environment.GetEnvironmentVariable("AZURESTORAGEKEY") ?? configuration.GetSection("BlobSettings:AzureStorageKey").Value;
            Configuration.AzurePublicContainer = Environment.GetEnvironmentVariable("PUBLICCONTAINER") ?? configuration.GetSection("BlobSettings:AzurePublicContainer").Value;
            Configuration.AzureVideosContainer = Environment.GetEnvironmentVariable("VIDEOSCONTAINER") ?? configuration.GetSection("BlobSettings:AzureVideosContainer").Value; 
            #endregion


            #region Add Service For DI
            services.AddAutoMapper(typeof(AutoMapperConfiguration));
           services.AddEndpointsApiExplorer();
            services.AddSwaggerGen(options =>
            {
                options.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme
                {
                    In=ParameterLocation.Header,   Description="Authentication Token",
                    Name="Authorization",          Type=SecuritySchemeType.Http,
                    BearerFormat="JsonWebToken",   Scheme="Bearer"
                });
                options.AddSecurityRequirement(new OpenApiSecurityRequirement
                {
                    {
                        new OpenApiSecurityScheme
                        {
                            Reference=new OpenApiReference
                            {
                                Type=ReferenceType.SecurityScheme,
                                Id="Bearer"
                            }
                        },
                       new string[]{}
                    }
                });
            });
            services.AddGrpc();
            services.AddMassTransit( x =>
            {
                x.AddConsumer<CastsConsumer>();
                x.AddBus(provider => Bus.Factory.CreateUsingRabbitMq(cfg =>
            {
                cfg.Host(new Uri(RabbitMqConfiguration.RmqUri), h =>
                {
                    h.Username(RabbitMqConfiguration.UserName);
                    h.Password(RabbitMqConfiguration.Password);
                });
                cfg.ReceiveEndpoint(RabbitMqConfiguration.Queue, ep =>
                {
                   // ep.PrefetchCount = 16;
                   // ep.UseMessageRetry(r => r.Interval(2, 100));
                    ep.ConfigureConsumer<CastsConsumer>(provider);
                });
            }));

            });

            

           
        

            services.AddScoped<IFrontEndService, FrontEndService>();
            services.AddScoped<IMoviesRepository, MoviesRepository>();
            services.AddScoped<ICastsRepository, CastsRepository>();
            services.AddScoped<ICategoriesRepository, CategoriesRepository>();
            services.AddScoped<IMoviesService, MoviesService>();
            services.AddScoped<IAccountService, AccountService>();
            services.AddScoped<IOtpRepository, OtpRepository>();
            services.AddScoped<IMovieCastsRepository, MovieCastsRepository>();
            services.AddScoped<IMovieCategoriesRepository, MovieCtegoriesRepository>();
            services.AddScoped<ICastsService, CastsService>();
            services.AddScoped<ICategoriesService, CategoriesService>();
            services.AddScoped<ITvShowCastsRepository, TvShowsCastsRepository>();
            services.AddScoped<ITvShowsCastService, TvShowCastService>();
            services.AddScoped<ITvShowCategoriesRepository,TvShowCategoryRepository>();
            services.AddScoped<ITvShowCategoriesService, TvShowCategoriesService>();

            #endregion

            #region KafkaConfiguration
           // services.AddSingleton<IHostedService, CategoryKafkaConsumer>();
            var kafkaConsumerBinding = new ConsumerConfig();
            var consumerSection = configuration.GetSection("KafkaConsumer");
            Configuration.KafkaServer = Environment.GetEnvironmentVariable("KAFKASERVER") ?? consumerSection["bootstrapservers"];
            consumerSection["bootstrapservers"] = Configuration.KafkaServer;
            ConfigurationBinder.Bind(consumerSection, kafkaConsumerBinding);
            services.AddSingleton(kafkaConsumerBinding);
            
            #endregion


            return services;

        } 
    }
}
